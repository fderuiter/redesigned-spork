// <auto-generated>
/*
 * Mednet EDC API
 *
 * The Mednet EDC (Electronic Data Capture) REST API provides a single-point of access for reading data stored across iMednet data services. This specification documents all available endpoints in the latest version of the API. 
 *
 * The version of the OpenAPI document: 1.0.15
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */

#nullable enable

using System;
using System.Collections;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Linq;
using System.IO;
using System.Text;
using System.Text.RegularExpressions;
using System.Text.Json;
using System.Text.Json.Serialization;
using System.ComponentModel.DataAnnotations;
using Org.OpenAPITools.Client;

namespace Org.OpenAPITools.Model
{
    /// <summary>
    /// Interval
    /// </summary>
    public partial class Interval : IValidatableObject
    {
        /// <summary>
        /// Initializes a new instance of the <see cref="Interval" /> class.
        /// </summary>
        /// <param name="studyKey">Unique study key</param>
        /// <param name="intervalId">Unique system identifier for the interval (visit definition)</param>
        /// <param name="intervalName">Name of the interval (visit) as defined in the study</param>
        /// <param name="intervalDescription">Description of the interval (visit)</param>
        /// <param name="intervalSequence">Sequence number of the interval in the schedule</param>
        /// <param name="intervalGroupId">Identifier for the interval group (if intervals are grouped)</param>
        /// <param name="intervalGroupName">Name of the interval group</param>
        /// <param name="timeline">Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)</param>
        /// <param name="definedUsingInterval">Baseline interval used for calculating this interval’s dates</param>
        /// <param name="windowCalculationForm">Baseline form (name) from which the calculation date is taken</param>
        /// <param name="windowCalculationDate">Baseline field (variable name) from which the calculation date is taken</param>
        /// <param name="actualDateForm">Form used to capture the actual date for this interval</param>
        /// <param name="actualDate">Field (variable name) used to capture the actual date for this interval</param>
        /// <param name="dueDateWillBeIn">Number of days from the calculation date when the interval is due</param>
        /// <param name="negativeSlack">Number of days before the due date that are allowed (negative window)</param>
        /// <param name="positiveSlack">Number of days after the due date that are allowed (positive window)</param>
        /// <param name="eproGracePeriod">Number of days of grace period for ePRO completion after due date</param>
        /// <param name="forms">List of forms that are scheduled in this interval</param>
        /// <param name="disabled">Whether the interval is soft-deleted (disabled)</param>
        /// <param name="dateCreated">Date when this interval was created</param>
        /// <param name="dateModified">Date when this interval was last modified</param>
        [JsonConstructor]
        public Interval(Option<string?> studyKey = default, Option<int?> intervalId = default, Option<string?> intervalName = default, Option<string?> intervalDescription = default, Option<int?> intervalSequence = default, Option<int?> intervalGroupId = default, Option<string?> intervalGroupName = default, Option<string?> timeline = default, Option<string?> definedUsingInterval = default, Option<string?> windowCalculationForm = default, Option<string?> windowCalculationDate = default, Option<string?> actualDateForm = default, Option<string?> actualDate = default, Option<int?> dueDateWillBeIn = default, Option<int?> negativeSlack = default, Option<int?> positiveSlack = default, Option<int?> eproGracePeriod = default, Option<List<ComponentsSchemasIntervalFormsItem>?> forms = default, Option<bool?> disabled = default, Option<string?> dateCreated = default, Option<string?> dateModified = default)
        {
            StudyKeyOption = studyKey;
            IntervalIdOption = intervalId;
            IntervalNameOption = intervalName;
            IntervalDescriptionOption = intervalDescription;
            IntervalSequenceOption = intervalSequence;
            IntervalGroupIdOption = intervalGroupId;
            IntervalGroupNameOption = intervalGroupName;
            TimelineOption = timeline;
            DefinedUsingIntervalOption = definedUsingInterval;
            WindowCalculationFormOption = windowCalculationForm;
            WindowCalculationDateOption = windowCalculationDate;
            ActualDateFormOption = actualDateForm;
            ActualDateOption = actualDate;
            DueDateWillBeInOption = dueDateWillBeIn;
            NegativeSlackOption = negativeSlack;
            PositiveSlackOption = positiveSlack;
            EproGracePeriodOption = eproGracePeriod;
            FormsOption = forms;
            DisabledOption = disabled;
            DateCreatedOption = dateCreated;
            DateModifiedOption = dateModified;
            OnCreated();
        }

        partial void OnCreated();

        /// <summary>
        /// Used to track the state of StudyKey
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> StudyKeyOption { get; private set; }

        /// <summary>
        /// Unique study key
        /// </summary>
        /// <value>Unique study key</value>
        [JsonPropertyName("studyKey")]
        public string? StudyKey { get { return this.StudyKeyOption; } set { this.StudyKeyOption = new(value); } }

        /// <summary>
        /// Used to track the state of IntervalId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> IntervalIdOption { get; private set; }

        /// <summary>
        /// Unique system identifier for the interval (visit definition)
        /// </summary>
        /// <value>Unique system identifier for the interval (visit definition)</value>
        [JsonPropertyName("intervalId")]
        public int? IntervalId { get { return this.IntervalIdOption; } set { this.IntervalIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of IntervalName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IntervalNameOption { get; private set; }

        /// <summary>
        /// Name of the interval (visit) as defined in the study
        /// </summary>
        /// <value>Name of the interval (visit) as defined in the study</value>
        [JsonPropertyName("intervalName")]
        public string? IntervalName { get { return this.IntervalNameOption; } set { this.IntervalNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of IntervalDescription
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IntervalDescriptionOption { get; private set; }

        /// <summary>
        /// Description of the interval (visit)
        /// </summary>
        /// <value>Description of the interval (visit)</value>
        [JsonPropertyName("intervalDescription")]
        public string? IntervalDescription { get { return this.IntervalDescriptionOption; } set { this.IntervalDescriptionOption = new(value); } }

        /// <summary>
        /// Used to track the state of IntervalSequence
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> IntervalSequenceOption { get; private set; }

        /// <summary>
        /// Sequence number of the interval in the schedule
        /// </summary>
        /// <value>Sequence number of the interval in the schedule</value>
        [JsonPropertyName("intervalSequence")]
        public int? IntervalSequence { get { return this.IntervalSequenceOption; } set { this.IntervalSequenceOption = new(value); } }

        /// <summary>
        /// Used to track the state of IntervalGroupId
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> IntervalGroupIdOption { get; private set; }

        /// <summary>
        /// Identifier for the interval group (if intervals are grouped)
        /// </summary>
        /// <value>Identifier for the interval group (if intervals are grouped)</value>
        [JsonPropertyName("intervalGroupId")]
        public int? IntervalGroupId { get { return this.IntervalGroupIdOption; } set { this.IntervalGroupIdOption = new(value); } }

        /// <summary>
        /// Used to track the state of IntervalGroupName
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> IntervalGroupNameOption { get; private set; }

        /// <summary>
        /// Name of the interval group
        /// </summary>
        /// <value>Name of the interval group</value>
        [JsonPropertyName("intervalGroupName")]
        public string? IntervalGroupName { get { return this.IntervalGroupNameOption; } set { this.IntervalGroupNameOption = new(value); } }

        /// <summary>
        /// Used to track the state of Timeline
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> TimelineOption { get; private set; }

        /// <summary>
        /// Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)
        /// </summary>
        /// <value>Type of interval visit window (e.g., None, Due Date, Start - End Date, Actual Date)</value>
        [JsonPropertyName("timeline")]
        public string? Timeline { get { return this.TimelineOption; } set { this.TimelineOption = new(value); } }

        /// <summary>
        /// Used to track the state of DefinedUsingInterval
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DefinedUsingIntervalOption { get; private set; }

        /// <summary>
        /// Baseline interval used for calculating this interval’s dates
        /// </summary>
        /// <value>Baseline interval used for calculating this interval’s dates</value>
        [JsonPropertyName("definedUsingInterval")]
        public string? DefinedUsingInterval { get { return this.DefinedUsingIntervalOption; } set { this.DefinedUsingIntervalOption = new(value); } }

        /// <summary>
        /// Used to track the state of WindowCalculationForm
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> WindowCalculationFormOption { get; private set; }

        /// <summary>
        /// Baseline form (name) from which the calculation date is taken
        /// </summary>
        /// <value>Baseline form (name) from which the calculation date is taken</value>
        [JsonPropertyName("windowCalculationForm")]
        public string? WindowCalculationForm { get { return this.WindowCalculationFormOption; } set { this.WindowCalculationFormOption = new(value); } }

        /// <summary>
        /// Used to track the state of WindowCalculationDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> WindowCalculationDateOption { get; private set; }

        /// <summary>
        /// Baseline field (variable name) from which the calculation date is taken
        /// </summary>
        /// <value>Baseline field (variable name) from which the calculation date is taken</value>
        [JsonPropertyName("windowCalculationDate")]
        public string? WindowCalculationDate { get { return this.WindowCalculationDateOption; } set { this.WindowCalculationDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of ActualDateForm
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ActualDateFormOption { get; private set; }

        /// <summary>
        /// Form used to capture the actual date for this interval
        /// </summary>
        /// <value>Form used to capture the actual date for this interval</value>
        [JsonPropertyName("actualDateForm")]
        public string? ActualDateForm { get { return this.ActualDateFormOption; } set { this.ActualDateFormOption = new(value); } }

        /// <summary>
        /// Used to track the state of ActualDate
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> ActualDateOption { get; private set; }

        /// <summary>
        /// Field (variable name) used to capture the actual date for this interval
        /// </summary>
        /// <value>Field (variable name) used to capture the actual date for this interval</value>
        [JsonPropertyName("actualDate")]
        public string? ActualDate { get { return this.ActualDateOption; } set { this.ActualDateOption = new(value); } }

        /// <summary>
        /// Used to track the state of DueDateWillBeIn
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> DueDateWillBeInOption { get; private set; }

        /// <summary>
        /// Number of days from the calculation date when the interval is due
        /// </summary>
        /// <value>Number of days from the calculation date when the interval is due</value>
        [JsonPropertyName("dueDateWillBeIn")]
        public int? DueDateWillBeIn { get { return this.DueDateWillBeInOption; } set { this.DueDateWillBeInOption = new(value); } }

        /// <summary>
        /// Used to track the state of NegativeSlack
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> NegativeSlackOption { get; private set; }

        /// <summary>
        /// Number of days before the due date that are allowed (negative window)
        /// </summary>
        /// <value>Number of days before the due date that are allowed (negative window)</value>
        [JsonPropertyName("negativeSlack")]
        public int? NegativeSlack { get { return this.NegativeSlackOption; } set { this.NegativeSlackOption = new(value); } }

        /// <summary>
        /// Used to track the state of PositiveSlack
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> PositiveSlackOption { get; private set; }

        /// <summary>
        /// Number of days after the due date that are allowed (positive window)
        /// </summary>
        /// <value>Number of days after the due date that are allowed (positive window)</value>
        [JsonPropertyName("positiveSlack")]
        public int? PositiveSlack { get { return this.PositiveSlackOption; } set { this.PositiveSlackOption = new(value); } }

        /// <summary>
        /// Used to track the state of EproGracePeriod
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<int?> EproGracePeriodOption { get; private set; }

        /// <summary>
        /// Number of days of grace period for ePRO completion after due date
        /// </summary>
        /// <value>Number of days of grace period for ePRO completion after due date</value>
        [JsonPropertyName("eproGracePeriod")]
        public int? EproGracePeriod { get { return this.EproGracePeriodOption; } set { this.EproGracePeriodOption = new(value); } }

        /// <summary>
        /// Used to track the state of Forms
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<List<ComponentsSchemasIntervalFormsItem>?> FormsOption { get; private set; }

        /// <summary>
        /// List of forms that are scheduled in this interval
        /// </summary>
        /// <value>List of forms that are scheduled in this interval</value>
        [JsonPropertyName("forms")]
        public List<ComponentsSchemasIntervalFormsItem>? Forms { get { return this.FormsOption; } set { this.FormsOption = new(value); } }

        /// <summary>
        /// Used to track the state of Disabled
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<bool?> DisabledOption { get; private set; }

        /// <summary>
        /// Whether the interval is soft-deleted (disabled)
        /// </summary>
        /// <value>Whether the interval is soft-deleted (disabled)</value>
        [JsonPropertyName("disabled")]
        public bool? Disabled { get { return this.DisabledOption; } set { this.DisabledOption = new(value); } }

        /// <summary>
        /// Used to track the state of DateCreated
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DateCreatedOption { get; private set; }

        /// <summary>
        /// Date when this interval was created
        /// </summary>
        /// <value>Date when this interval was created</value>
        [JsonPropertyName("dateCreated")]
        public string? DateCreated { get { return this.DateCreatedOption; } set { this.DateCreatedOption = new(value); } }

        /// <summary>
        /// Used to track the state of DateModified
        /// </summary>
        [JsonIgnore]
        [global::System.ComponentModel.EditorBrowsable(global::System.ComponentModel.EditorBrowsableState.Never)]
        public Option<string?> DateModifiedOption { get; private set; }

        /// <summary>
        /// Date when this interval was last modified
        /// </summary>
        /// <value>Date when this interval was last modified</value>
        [JsonPropertyName("dateModified")]
        public string? DateModified { get { return this.DateModifiedOption; } set { this.DateModifiedOption = new(value); } }

        /// <summary>
        /// Returns the string presentation of the object
        /// </summary>
        /// <returns>String presentation of the object</returns>
        public override string ToString()
        {
            StringBuilder sb = new StringBuilder();
            sb.Append("class Interval {\n");
            sb.Append("  StudyKey: ").Append(StudyKey).Append("\n");
            sb.Append("  IntervalId: ").Append(IntervalId).Append("\n");
            sb.Append("  IntervalName: ").Append(IntervalName).Append("\n");
            sb.Append("  IntervalDescription: ").Append(IntervalDescription).Append("\n");
            sb.Append("  IntervalSequence: ").Append(IntervalSequence).Append("\n");
            sb.Append("  IntervalGroupId: ").Append(IntervalGroupId).Append("\n");
            sb.Append("  IntervalGroupName: ").Append(IntervalGroupName).Append("\n");
            sb.Append("  Timeline: ").Append(Timeline).Append("\n");
            sb.Append("  DefinedUsingInterval: ").Append(DefinedUsingInterval).Append("\n");
            sb.Append("  WindowCalculationForm: ").Append(WindowCalculationForm).Append("\n");
            sb.Append("  WindowCalculationDate: ").Append(WindowCalculationDate).Append("\n");
            sb.Append("  ActualDateForm: ").Append(ActualDateForm).Append("\n");
            sb.Append("  ActualDate: ").Append(ActualDate).Append("\n");
            sb.Append("  DueDateWillBeIn: ").Append(DueDateWillBeIn).Append("\n");
            sb.Append("  NegativeSlack: ").Append(NegativeSlack).Append("\n");
            sb.Append("  PositiveSlack: ").Append(PositiveSlack).Append("\n");
            sb.Append("  EproGracePeriod: ").Append(EproGracePeriod).Append("\n");
            sb.Append("  Forms: ").Append(Forms).Append("\n");
            sb.Append("  Disabled: ").Append(Disabled).Append("\n");
            sb.Append("  DateCreated: ").Append(DateCreated).Append("\n");
            sb.Append("  DateModified: ").Append(DateModified).Append("\n");
            sb.Append("}\n");
            return sb.ToString();
        }

        /// <summary>
        /// To validate all properties of the instance
        /// </summary>
        /// <param name="validationContext">Validation context</param>
        /// <returns>Validation Result</returns>
        IEnumerable<ValidationResult> IValidatableObject.Validate(ValidationContext validationContext)
        {
            yield break;
        }
    }

    /// <summary>
    /// A Json converter for type <see cref="Interval" />
    /// </summary>
    public class IntervalJsonConverter : JsonConverter<Interval>
    {
        /// <summary>
        /// Deserializes json to <see cref="Interval" />
        /// </summary>
        /// <param name="utf8JsonReader"></param>
        /// <param name="typeToConvert"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <returns></returns>
        /// <exception cref="JsonException"></exception>
        public override Interval Read(ref Utf8JsonReader utf8JsonReader, Type typeToConvert, JsonSerializerOptions jsonSerializerOptions)
        {
            int currentDepth = utf8JsonReader.CurrentDepth;

            if (utf8JsonReader.TokenType != JsonTokenType.StartObject && utf8JsonReader.TokenType != JsonTokenType.StartArray)
                throw new JsonException();

            JsonTokenType startingTokenType = utf8JsonReader.TokenType;

            Option<string?> studyKey = default;
            Option<int?> intervalId = default;
            Option<string?> intervalName = default;
            Option<string?> intervalDescription = default;
            Option<int?> intervalSequence = default;
            Option<int?> intervalGroupId = default;
            Option<string?> intervalGroupName = default;
            Option<string?> timeline = default;
            Option<string?> definedUsingInterval = default;
            Option<string?> windowCalculationForm = default;
            Option<string?> windowCalculationDate = default;
            Option<string?> actualDateForm = default;
            Option<string?> actualDate = default;
            Option<int?> dueDateWillBeIn = default;
            Option<int?> negativeSlack = default;
            Option<int?> positiveSlack = default;
            Option<int?> eproGracePeriod = default;
            Option<List<ComponentsSchemasIntervalFormsItem>?> forms = default;
            Option<bool?> disabled = default;
            Option<string?> dateCreated = default;
            Option<string?> dateModified = default;

            while (utf8JsonReader.Read())
            {
                if (startingTokenType == JsonTokenType.StartObject && utf8JsonReader.TokenType == JsonTokenType.EndObject && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (startingTokenType == JsonTokenType.StartArray && utf8JsonReader.TokenType == JsonTokenType.EndArray && currentDepth == utf8JsonReader.CurrentDepth)
                    break;

                if (utf8JsonReader.TokenType == JsonTokenType.PropertyName && currentDepth == utf8JsonReader.CurrentDepth - 1)
                {
                    string? localVarJsonPropertyName = utf8JsonReader.GetString();
                    utf8JsonReader.Read();

                    switch (localVarJsonPropertyName)
                    {
                        case "studyKey":
                            studyKey = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "intervalId":
                            intervalId = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "intervalName":
                            intervalName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "intervalDescription":
                            intervalDescription = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "intervalSequence":
                            intervalSequence = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "intervalGroupId":
                            intervalGroupId = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "intervalGroupName":
                            intervalGroupName = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "timeline":
                            timeline = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "definedUsingInterval":
                            definedUsingInterval = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "windowCalculationForm":
                            windowCalculationForm = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "windowCalculationDate":
                            windowCalculationDate = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "actualDateForm":
                            actualDateForm = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "actualDate":
                            actualDate = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "dueDateWillBeIn":
                            dueDateWillBeIn = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "negativeSlack":
                            negativeSlack = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "positiveSlack":
                            positiveSlack = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "eproGracePeriod":
                            eproGracePeriod = new Option<int?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (int?)null : utf8JsonReader.GetInt32());
                            break;
                        case "forms":
                            forms = new Option<List<ComponentsSchemasIntervalFormsItem>?>(JsonSerializer.Deserialize<List<ComponentsSchemasIntervalFormsItem>>(ref utf8JsonReader, jsonSerializerOptions)!);
                            break;
                        case "disabled":
                            disabled = new Option<bool?>(utf8JsonReader.TokenType == JsonTokenType.Null ? (bool?)null : utf8JsonReader.GetBoolean());
                            break;
                        case "dateCreated":
                            dateCreated = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        case "dateModified":
                            dateModified = new Option<string?>(utf8JsonReader.GetString()!);
                            break;
                        default:
                            break;
                    }
                }
            }

            if (studyKey.IsSet && studyKey.Value == null)
                throw new ArgumentNullException(nameof(studyKey), "Property is not nullable for class Interval.");

            if (intervalId.IsSet && intervalId.Value == null)
                throw new ArgumentNullException(nameof(intervalId), "Property is not nullable for class Interval.");

            if (intervalName.IsSet && intervalName.Value == null)
                throw new ArgumentNullException(nameof(intervalName), "Property is not nullable for class Interval.");

            if (intervalDescription.IsSet && intervalDescription.Value == null)
                throw new ArgumentNullException(nameof(intervalDescription), "Property is not nullable for class Interval.");

            if (intervalSequence.IsSet && intervalSequence.Value == null)
                throw new ArgumentNullException(nameof(intervalSequence), "Property is not nullable for class Interval.");

            if (intervalGroupId.IsSet && intervalGroupId.Value == null)
                throw new ArgumentNullException(nameof(intervalGroupId), "Property is not nullable for class Interval.");

            if (intervalGroupName.IsSet && intervalGroupName.Value == null)
                throw new ArgumentNullException(nameof(intervalGroupName), "Property is not nullable for class Interval.");

            if (timeline.IsSet && timeline.Value == null)
                throw new ArgumentNullException(nameof(timeline), "Property is not nullable for class Interval.");

            if (definedUsingInterval.IsSet && definedUsingInterval.Value == null)
                throw new ArgumentNullException(nameof(definedUsingInterval), "Property is not nullable for class Interval.");

            if (windowCalculationForm.IsSet && windowCalculationForm.Value == null)
                throw new ArgumentNullException(nameof(windowCalculationForm), "Property is not nullable for class Interval.");

            if (windowCalculationDate.IsSet && windowCalculationDate.Value == null)
                throw new ArgumentNullException(nameof(windowCalculationDate), "Property is not nullable for class Interval.");

            if (actualDateForm.IsSet && actualDateForm.Value == null)
                throw new ArgumentNullException(nameof(actualDateForm), "Property is not nullable for class Interval.");

            if (actualDate.IsSet && actualDate.Value == null)
                throw new ArgumentNullException(nameof(actualDate), "Property is not nullable for class Interval.");

            if (dueDateWillBeIn.IsSet && dueDateWillBeIn.Value == null)
                throw new ArgumentNullException(nameof(dueDateWillBeIn), "Property is not nullable for class Interval.");

            if (negativeSlack.IsSet && negativeSlack.Value == null)
                throw new ArgumentNullException(nameof(negativeSlack), "Property is not nullable for class Interval.");

            if (positiveSlack.IsSet && positiveSlack.Value == null)
                throw new ArgumentNullException(nameof(positiveSlack), "Property is not nullable for class Interval.");

            if (eproGracePeriod.IsSet && eproGracePeriod.Value == null)
                throw new ArgumentNullException(nameof(eproGracePeriod), "Property is not nullable for class Interval.");

            if (forms.IsSet && forms.Value == null)
                throw new ArgumentNullException(nameof(forms), "Property is not nullable for class Interval.");

            if (disabled.IsSet && disabled.Value == null)
                throw new ArgumentNullException(nameof(disabled), "Property is not nullable for class Interval.");

            if (dateCreated.IsSet && dateCreated.Value == null)
                throw new ArgumentNullException(nameof(dateCreated), "Property is not nullable for class Interval.");

            if (dateModified.IsSet && dateModified.Value == null)
                throw new ArgumentNullException(nameof(dateModified), "Property is not nullable for class Interval.");

            return new Interval(studyKey, intervalId, intervalName, intervalDescription, intervalSequence, intervalGroupId, intervalGroupName, timeline, definedUsingInterval, windowCalculationForm, windowCalculationDate, actualDateForm, actualDate, dueDateWillBeIn, negativeSlack, positiveSlack, eproGracePeriod, forms, disabled, dateCreated, dateModified);
        }

        /// <summary>
        /// Serializes a <see cref="Interval" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="interval"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public override void Write(Utf8JsonWriter writer, Interval interval, JsonSerializerOptions jsonSerializerOptions)
        {
            writer.WriteStartObject();

            WriteProperties(writer, interval, jsonSerializerOptions);
            writer.WriteEndObject();
        }

        /// <summary>
        /// Serializes the properties of <see cref="Interval" />
        /// </summary>
        /// <param name="writer"></param>
        /// <param name="interval"></param>
        /// <param name="jsonSerializerOptions"></param>
        /// <exception cref="NotImplementedException"></exception>
        public void WriteProperties(Utf8JsonWriter writer, Interval interval, JsonSerializerOptions jsonSerializerOptions)
        {
            if (interval.StudyKeyOption.IsSet && interval.StudyKey == null)
                throw new ArgumentNullException(nameof(interval.StudyKey), "Property is required for class Interval.");

            if (interval.IntervalNameOption.IsSet && interval.IntervalName == null)
                throw new ArgumentNullException(nameof(interval.IntervalName), "Property is required for class Interval.");

            if (interval.IntervalDescriptionOption.IsSet && interval.IntervalDescription == null)
                throw new ArgumentNullException(nameof(interval.IntervalDescription), "Property is required for class Interval.");

            if (interval.IntervalGroupNameOption.IsSet && interval.IntervalGroupName == null)
                throw new ArgumentNullException(nameof(interval.IntervalGroupName), "Property is required for class Interval.");

            if (interval.TimelineOption.IsSet && interval.Timeline == null)
                throw new ArgumentNullException(nameof(interval.Timeline), "Property is required for class Interval.");

            if (interval.DefinedUsingIntervalOption.IsSet && interval.DefinedUsingInterval == null)
                throw new ArgumentNullException(nameof(interval.DefinedUsingInterval), "Property is required for class Interval.");

            if (interval.WindowCalculationFormOption.IsSet && interval.WindowCalculationForm == null)
                throw new ArgumentNullException(nameof(interval.WindowCalculationForm), "Property is required for class Interval.");

            if (interval.WindowCalculationDateOption.IsSet && interval.WindowCalculationDate == null)
                throw new ArgumentNullException(nameof(interval.WindowCalculationDate), "Property is required for class Interval.");

            if (interval.ActualDateFormOption.IsSet && interval.ActualDateForm == null)
                throw new ArgumentNullException(nameof(interval.ActualDateForm), "Property is required for class Interval.");

            if (interval.ActualDateOption.IsSet && interval.ActualDate == null)
                throw new ArgumentNullException(nameof(interval.ActualDate), "Property is required for class Interval.");

            if (interval.FormsOption.IsSet && interval.Forms == null)
                throw new ArgumentNullException(nameof(interval.Forms), "Property is required for class Interval.");

            if (interval.DateCreatedOption.IsSet && interval.DateCreated == null)
                throw new ArgumentNullException(nameof(interval.DateCreated), "Property is required for class Interval.");

            if (interval.DateModifiedOption.IsSet && interval.DateModified == null)
                throw new ArgumentNullException(nameof(interval.DateModified), "Property is required for class Interval.");

            if (interval.StudyKeyOption.IsSet)
                writer.WriteString("studyKey", interval.StudyKey);

            if (interval.IntervalIdOption.IsSet)
                writer.WriteNumber("intervalId", interval.IntervalIdOption.Value!.Value);

            if (interval.IntervalNameOption.IsSet)
                writer.WriteString("intervalName", interval.IntervalName);

            if (interval.IntervalDescriptionOption.IsSet)
                writer.WriteString("intervalDescription", interval.IntervalDescription);

            if (interval.IntervalSequenceOption.IsSet)
                writer.WriteNumber("intervalSequence", interval.IntervalSequenceOption.Value!.Value);

            if (interval.IntervalGroupIdOption.IsSet)
                writer.WriteNumber("intervalGroupId", interval.IntervalGroupIdOption.Value!.Value);

            if (interval.IntervalGroupNameOption.IsSet)
                writer.WriteString("intervalGroupName", interval.IntervalGroupName);

            if (interval.TimelineOption.IsSet)
                writer.WriteString("timeline", interval.Timeline);

            if (interval.DefinedUsingIntervalOption.IsSet)
                writer.WriteString("definedUsingInterval", interval.DefinedUsingInterval);

            if (interval.WindowCalculationFormOption.IsSet)
                writer.WriteString("windowCalculationForm", interval.WindowCalculationForm);

            if (interval.WindowCalculationDateOption.IsSet)
                writer.WriteString("windowCalculationDate", interval.WindowCalculationDate);

            if (interval.ActualDateFormOption.IsSet)
                writer.WriteString("actualDateForm", interval.ActualDateForm);

            if (interval.ActualDateOption.IsSet)
                writer.WriteString("actualDate", interval.ActualDate);

            if (interval.DueDateWillBeInOption.IsSet)
                writer.WriteNumber("dueDateWillBeIn", interval.DueDateWillBeInOption.Value!.Value);

            if (interval.NegativeSlackOption.IsSet)
                writer.WriteNumber("negativeSlack", interval.NegativeSlackOption.Value!.Value);

            if (interval.PositiveSlackOption.IsSet)
                writer.WriteNumber("positiveSlack", interval.PositiveSlackOption.Value!.Value);

            if (interval.EproGracePeriodOption.IsSet)
                writer.WriteNumber("eproGracePeriod", interval.EproGracePeriodOption.Value!.Value);

            if (interval.FormsOption.IsSet)
            {
                writer.WritePropertyName("forms");
                JsonSerializer.Serialize(writer, interval.Forms, jsonSerializerOptions);
            }
            if (interval.DisabledOption.IsSet)
                writer.WriteBoolean("disabled", interval.DisabledOption.Value!.Value);

            if (interval.DateCreatedOption.IsSet)
                writer.WriteString("dateCreated", interval.DateCreated);

            if (interval.DateModifiedOption.IsSet)
                writer.WriteString("dateModified", interval.DateModified);
        }
    }
}
